type Account @entity {
  id: ID!
  accountId: BigInt!
  address: String!
  metadata: String!

  ownedNodes: [Node!]! @derivedFrom(field: "owner")

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

type AuthorizedAccountIssuer @entity {
  id: ID!
  address: String!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

enum NodeType {
  UNKNOWN
  METALABEL
  RELEASE
}

type Node @entity {
  id: ID!
  nodeId: BigInt!
  nodeType: NodeType!
  metadata: String!
  owner: Account
  parent: Node
  groupNode: Node

  collections: [Collection!]! @derivedFrom(field: "controlNode")
  memberships: [Memberships!]! @derivedFrom(field: "controlNode")
  children: [Node!]! @derivedFrom(field: "parent")
  groupChildren: [Node!]! @derivedFrom(field: "groupNode")
  controllers: [NodeController!]! @derivedFrom(field: "node")
  sequences: [Sequence!]! @derivedFrom(field: "dropNode")
  records: [Record!]! @derivedFrom(field: "dropNode")

  collectionCount: Int!
  membershipsCount: Int!
  childrenCount: Int!
  groupChildrenCount: Int!
  controllerCount: Int!
  sequenceCount: Int!
  recordCount: Int!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

type NodeController @entity {
  id: ID!
  node: Node!
  address:  String!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}


type Collection @entity {
  id: ID!
  address: String!
  name: String!
  symbol: String!
  ownerAddress: String!
  controlNode: Node!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!

  recordCount: Int!
  sequenceCount: Int!

  records: [Record!]! @derivedFrom(field: "collection")
  sequences: [Sequence!]! @derivedFrom(field: "collection")
}

type Record @entity {
  id: ID!
  tokenId: BigInt!
  sequence: Sequence!
  ownerAddress: String!
  data: BigInt!

  collection: Collection! # denormalized, sequence -> ccollection
  dropNode: Node! # denormalized, sequence -> dropNode

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

type Sequence @entity {
  id: ID!
  collection: Collection!
  sequenceId: Int!
  dropNode: Node!
  engineAddress: String!
  maxSupply: BigInt # null if none
  sealedBeforeTimestamp: BigInt!
  sealedAfterTimestamp: BigInt!
  engineData: String!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!

  recordCount: Int!

  # only present for drop engine sequences
  unitPrice: BigInt # in wei
  revenueRecipient: String
  royaltyBps: Int
  uriPrefix: String
  isPublicMint: Boolean
  mintAuthority: String # null if public mint

  records: [Record!]! @derivedFrom(field: "sequence")
}

type Memberships @entity {
  id: ID!
  address: String!
  name: String!
  symbol: String!
  ownerAddress: String!
  controlNode: Node!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!

  membershipNFTCount: Int!

  membershipNFTs: [MembershipNFT!]! @derivedFrom(field: "memberships")
}

type MembershipNFT @entity {
  id: ID!
  tokenId: BigInt!
  ownerAddress: String!

  memberships: Memberships!
  controlNode: Node! # denormalized, memberships -> controlNode

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

# type Split @entity {
#   id: ID!
#   address: String!
#   controlNode: Node!
#   metadata: String!
#   recipientAddresses: [String!]! # parallel array w below
#   recipientAllocations: [Int!]! # raw values from 0xsplit, 1e6 = 100%

#   createdAtTimestamp: BigInt!
#   createdAtTransaction: Bytes!
# }

# type Waterfall @entity {
#   id: ID!
#   address: String!
#   controlNode: Node!
#   metadata: String!
#   recipientAddresses: [String!]! # all recipients, including residual address
#   recipientThresholds: [BigInt!]! # should have length 1 less than recipient array
#   nonWaterfallRecipientAddress: String!
#   tokenAddress: String # if null, waterfall is in native ETH

#   createdAtTimestamp: BigInt!
#   createdAtTransaction: Bytes!
# }
