type Account @entity {
  id: ID!
  accountId: BigInt!
  address: String!
  recoveryAddress: String!
  metadata: String!
  username: String

  ownedNodes: [Node!]! @derivedFrom(field: "owner")

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

enum NodeType {
  UNKNOWN
  METALABEL
  SQUAD
  RELEASE
  DROP
  TREASURY
  SPLIT
  REALM
}

type Node @entity {
  id: ID!
  nodeId: BigInt!
  nodeType: NodeType!
  metadata: String!
  owner: Account
  parent: Node
  groupNode: Node

  collections: [Collection!]! @derivedFrom(field: "controlNode")
  children: [Node!]! @derivedFrom(field: "parent")
  groupChildren: [Node!]! @derivedFrom(field: "groupNode")
  controllers: [NodeController!]! @derivedFrom(field: "node")
  sequences: [Sequence!]! @derivedFrom(field: "dropNode")
  records: [Record!]! @derivedFrom(field: "dropNode")
  splits: [Split!]! @derivedFrom(field: "controlNode")

  collectionCount: Int!
  childrenCount: Int!
  groupChildrenCount: Int!
  controllerCount: Int!
  sequenceCount: Int!
  recordCount: Int!
  splitCount: Int!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

type NodeController @entity {
  id: ID!
  node: Node!
  address:  String!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

type Collection @entity {
  id: ID!
  address: String!
  name: String!
  symbol: String!
  ownerAddress: String!
  controlNode: Node!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!

  recordCount: Int!
  sequenceCount: Int!

  records: [Record!]! @derivedFrom(field: "collection")
  sequences: [Sequence!]! @derivedFrom(field: "collection")
}

type Record @entity {
  id: ID!
  tokenId: BigInt!
  sequence: Sequence!
  etching: String!
  ownerAddress: String!
  data: BigInt!

  collection: Collection! # denormalized, sequence -> ccollection
  dropNode: Node! # denormalized, sequence -> dropNode

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}

type Sequence @entity {
  id: ID!
  collection: Collection!
  sequenceId: Int!
  dropNode: Node!
  engineAddress: String!
  maxSupply: BigInt # null if none
  sealedBeforeTimestamp: BigInt!
  sealedAfterTimestamp: BigInt!
  engineData: String!

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!

  recordCount: Int!

  records: [Record!]! @derivedFrom(field: "sequence")
}

type Split @entity {
  id: ID!
  address: String!
  controlNode: Node!
  metadata: String!
  recipientAddresses: [String!]! # parallel array w below
  recipientAllocations: [Int!]! # raw values from 0xsplit, 1e6 = 100%

  createdAtTimestamp: BigInt!
  createdAtTransaction: Bytes!
}
